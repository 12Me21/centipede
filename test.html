<!doctype html><meta charset=utf-8>

<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 500 1000" width=1000>
	<style>
		@font-face {
			font-family: 'mspm';
			src: url("./short2.otf?1");
		}
		
		.chip rect {
			fill: beige;
			stroke: maroon;
			stroke-width: 2px;
		}
		.chip text {
			dominant-baseline: central;
			font-size: 7px;
			fill: black;
			font-family: ms pmincho;
		}
		.chip path {
			stroke: maroon;
			stroke-width: 2px;
			stroke-linecap: round;
		}
		.r {
			text-anchor: end;
		}
		.ol {
			text-decoration: overline;
		}
		.chip .name {
			dominant-baseline: auto;
			text-anchor: middle;
			font-size: 8px;
			font-weight: bold;
		}
		.chip .desc {
			dominant-baseline: auto;
			text-anchor: middle;
			font-size: 6px;
		}
		.chip .num {
			dominant-baseline: auto;
			font-size: 6px;
			fill: #008;
		}
		.net.net {
			stroke: none;
			fill: blue;
			font-size: 8px;
			dominant-baseline: central;
			font-family: ms pmincho
		}
		.overline {
			text-decoration: underline;
			text-underline-offset: -6px;
			text-decoration-skip-ink: none;
			text-underline-position: from-font;
		}
		.crossing {
			fill: white;
			stroke: none;
		}
		.junction {
			fill: green;
			stroke: none;
		}
	</style>
	<g id=$dest>
	</g>
</svg>

<script>
	class Point {
		strattr() {
			return ` x=${this.x*10} y=${this.y*10}`
		}
		strsp() {
			return `${this.x*10} ${this.y*10}`
		}
	}
	let P = Point.prototype
	
	class Pin {
		constructor(desc, component) {
			if ('string'==typeof desc) {
				let m = /^(\d+) (\S+) (?:@(\d+),(\d+))?/.exec(desc)
				if (!m)
					throw new Error("invalid pin descriptor: “"+desc+"”")
				let [_,num,name,side,slot] = m
				this.name = name
				this.num = num
				side = +side | 0
				slot = +slot | 0
				while (component.used[side][slot])
					slot++
				component.used[side][slot] = true
				this.side = side
				this.slot = slot
			} else {
				Object.assign(this, desc)
			}
			this.calculate_position(component)
		}
		calculate_position(component) {
			this.r = {
				x: [this.slot,component.width,component.width-this.slot,0][this.side],
				y: [0,this.slot,component.height,component.height-this.slot][this.side],
				dir: ["v-10","h10","v10","h-10"][this.side],
				//diro: ["h-1l1,-1l1,1h-1v-10","v-3l3,3l-3,3v-3 h10","v10","h-10"][this.side],
			}
			this.e = {
				x: this.r.x + [0,1,0,-1][this.side],
				y: this.r.y + [-1,0,1,0][this.side],
			}
		}
		todesc() {
			return this.num+" "+this.name+" @"+this.side+","+this.slot
		}
	}
	
	class Component {
		constructor(obj) {
			let self = Object.setPrototypeOf(obj, Component.prototype)
			self.used = [[],[],[],[]]
			self.pins = self.pins.map(x=>new Pin(x, self))
			//self.pins2 = self.pins.map(x=>x.todesc())
			return self
		}
	}
	
	let comps = {
		f74a: new Component({
			width: 3,
			height: 5,
			name: "74F74",
			desc: "d-flip-flop",
			pins: [
				"1 ~CLR @3,1",
				"2 D @3,4",
				"3 CLK @3,3",
				"4 ~PRE @3,2",
				"5 Q @1,2",
				"6 ~Q @1,1",
			],
		}),
		f74b: new Component({
			width: 3,
			height: 5,
			name: "74F74",
			desc: "(cont.)",
			pins: [
				"8 ~Q @1,1",
				"9 Q @1,2",
				"10 ~PRE @3,2",
				"11 CLK @3,3",
				"12 D @3,4",
				"13 ~CLR @3,1",
			],
		}),
		f161: new Component({
			width: 4,
			height: 12,
			name: "74F161",
			desc: "binary counter",
			pins: [
				"1 ~MR @3,1",
				"2 CLK @3,3",
				"3 D0 @3,11",
				"4 D1 @3,10",
				"5 D2 @3,9",
				"6 D3 @3,8",
				"7 ENP @3,5",
				
				"9 ~LOAD @3,6",
				"10 ENT @3,4",
				"11 Q3 @1,4",
				"12 Q2 @1,3",
				"13 Q1 @1,2",
				"14 Q0 @1,1",
				"15 RCO @1,10",
			],
		}),
		dpraml: new Component({
			width: 4,
			height: 16,
			name: "MB8421 L",
			desc: "dual-port RAM",
			pins: [
				"1 ~CS @3,3",
				"2 ~WE @3,2",
				"3 ~BUSY @1,12",
				"4 ~INT @1,13",
				
				"6 A10 @3,5",
				"7 ~OE @3,1",
				"8 A0 @3,15",
				"9 A1 @3,14",
				"10 A2 @3,13",
				"11 A3 @3,12",
				"12 A4 @3,11",
				"13 A5 @3,10",
				"14 A6 @3,9",
				"15 A7 @3,8",
				"16 A8 @3,7",
				"17 A9 @3,6",
				"18 IO0 @1,1",
				"19 IO1 @1,2",
				"20 IO2 @1,3",
				"21 IO3 @1,4",
				"22 IO4 @1,5",
				"23 IO5 @1,6",
				"24 IO6 @1,7",
				"25 IO7 @1,8",
			],
		}),
		f04: new Component({
			width: 3,
			height: 7,
			name: "74F04",
			desc: "inverter",
			pins: [
				"1 I1 @3,1",
				"2 ~Y1 @1,6",
				"3 I2 @3,2",
				"4 ~Y2 @1,5",
				"5 I3 @3,3",
				"6 ~Y3 @1,4",
				
				"8 ~Y4 @1,3",
				"9 I4 @3,4",
				"10 ~Y5 @1,2",
				"11 I5 @3,5",
				"12 ~Y6 @1,1",
				"13 I6 @3,6",
			],
		}),
		osc: new Component({
			width:3,
			height: 2,
			name: "oscillator",
			pins: [
				"8 CLK @1,1",
			],
		}),
		f244a: new Component({
			width: 3,
			height: 7,
			name: "74F244",
			desc: "buffer",
			pins: [
				"1 ~OE @3,1",
				"2 I0 @3,6",
				"4 I1 @3,5",
				"6 I2 @3,4",
				"8 I3 @3,3",
				"12 Y3 @1,4",
				"14 Y2 @1,3",
				"16 Y1 @1,2",
				"18 Y0 @1,1",
			],
		}),
		f244b: new Component({
			width: 3,
			height: 7,
			name: "74F244",
			desc: "buffer",
			pins: [
				"19 ~OE @3,1",
				"17 I0 @3,6",
				"15 I1 @3,5",
				"13 I2 @3,4",
				"11 I3 @3,3",
				"9 Y3 @1,4",
				"7 Y2 @1,3",
				"5 Y1 @1,2",
				"3 Y0 @1,1",
			],
		}),
	}
	
	let placed = [
		{
			name: "IC21A",
			displayname: "IC21:1",
			symbol: comps.f74a,
			pos: {x:12-5, y:11},
		},
		{
			name: "IC21B",
			displayname: "IC21:2",
			symbol: comps.f74b,
			pos: {x:19-5, y:11},
		},
		{
			name: "IC22",
			symbol: comps.f161,
			pos: {x:30-3-5, y:11-5},
		},
		{
			name: "IC30L",
			displayname: "IC30:L",
			symbol: comps.dpraml,
			pos: {x:35-5, y:10-5},
		},
		
		{
			name: "IC64A",
			symbol: comps.f74a,
			pos: {x:12, y:11+4+10},
		},
		{
			name: "IC64B",
			symbol: comps.f74b,
			pos: {x:19+2, y:11+5+10},
		},
		{
			name: "IC65",
			symbol: comps.f04,
			pos: {x:5, y:11+5+10},
		},
		
		{
			name: "IC19:B",
			symbol: comps.f74b,
			pos: {x:22-10, y:10+25+10},
		},
		{
			name: "IC19:A",
			symbol: comps.f74a,
			pos: {x:29-10, y:10+25+10},
		},
		{
			name: "X1",
			symbol: comps.osc,
			pos: {x:16-10, y:11+25+10},
		},
		{
			name: "IC20:A",
			symbol: comps.f244a,
			pos: {x:40-2-10, y:11+16+2+10},
		},
		{
			name: "IC20:B",
			symbol: comps.f244b,
			pos: {x:40-2-10, y:11+25+2+10},
		},
		{
			name: "X2",
			symbol: comps.osc,
			pos: {x:16+10-10, y:11+20+10-1},
		},
		{
			name: "X3",
			symbol: comps.osc,
			pos: {x:16+5+10-10, y:11+15+3+10-1},
		},
	]
	
	let cons = [
		"IC22.D0 IC22.D1 IC22.D2 IC22.D3 GND",
		
		"IC22.~LOAD VCC",
		"IC22.RCO NC",
		
		"IC21A.D +v-3h5 IC21A.~Q",
		"IC21B.D +v-3h5 IC21B.~Q",
		
		"ic21a.q +h1J ic21b.clk +Pv5h7v-3 ic22.clk",
		
		"IC22.Q0 IC30L.A1",
		"IC22.Q1 IC30L.A2",
		"IC22.Q2 IC30L.A3",
		"IC22.Q3 IC30L.A4",
		"IC21A.CLK =OTIS.E",
		
		"IC21A.~PRE GND",
		"IC21B.~PRE GND",
		"<circle cx=120 cy=170 r=1.5 class=crossing />",
		"<circle cx=190 cy=170 r=1.5 class=crossing />",
		
		"ic21a.~clr =OTIS.BS +v2h7J ic21b.~clr +P ic22.~mr",
		
		"ic21b.q +h2J ic22.enp ic22.ent +Pv-9h8v2 ic30l.a0",
		
		"ic30l.a5 ic30l.a6 ic30l.a7 ic30l.a8 ic30l.a9 ic30l.a10 GND",
		
		"IC30L.IO4 NC",
		"IC30L.IO5 NC",
		"IC30L.IO6 NC",
		"IC30L.IO7 NC",
		
		"IC30L.IO0 =cartB.89",
		"IC30L.IO1 =cartB.90",
		"IC30L.IO2 =cartB.91",
		"IC30L.IO3 =cartB.92",
		
		"IC30L.~OE GND",
		
		"IC30L.~BUSY +h1v5h-8v-3 IC30L.~WE", // unsure
		
		"IC65.13 =FDP.205",
		"IC65.12 IC64A.3",
		"IC65.11 =CPU.AS",
		"IC65.10 +h1J IC64A.4 +Pv3h6v-2 IC64B.10",
		"IC64A.5 IC64B.12",
		"IC64B.9 =FCM.109",
		"IC64B.11 =~VRAM-CE", //], /*"h-10 v60 h-100"*/""],
		
		"IC64A.1 VCC",
		"IC64A.2 GND",
		"IC64B.13 VCC",
		"IC64A.~Q NC",
		"IC64B.~Q NC",
		
		"IC19:B.D +v-3h5 IC19:B.~Q",
		"IC19:A.D +v-3h5 IC19:A.~Q",
		"IC19:B.Q +h1J IC19:A.CLK +Pv4h9J IC20:B.I2 +Pv-9 IC20:A.I2",
		"IC19:B.~PRE IC19:B.~CLR GND",
		"IC19:A.~PRE IC19:A.~CLR GND",
		"IC19:A.Q +h2Jv-4 IC20:A.I3 +Pv5 IC20:B.I3",
		"X1.CLK IC19:B.CLK",
		
		"IC20:A.~OE GND",
		"IC20:B.~OE GND",
		"IC20:B.I1 GND",
		
		"X3.CLK +h1v1 IC20:A.I0",
		"X2.CLK IC20:A.I1",
	]
	
	let byname = {}
	for (let p of placed)
		byname[p.name] = p
	
	function generate_symbol({name, displayname, suffix="", symbol:def, pos:{x, y}}) {
		let s = ''
		let {width, height} = def
		s += `<g class=chip>`
		s += `<text x=${(x+width/2)*10} y=${(y-0.8)*10} class=name >${displayname || name}${suffix}</text>`
		s += `<text x=${(x+width/2)*10} y=${(y-0.2)*10} class=desc >${def.name} ${def.desc}</text>`
		s += `<rect x=${(x)*10} y=${(y)*10} width=${(width)*10} height=${(height)*10} />`
		for (let p of def.pins) {
			let px = x + p.r.x
			let py = y + p.r.y
			//let dir = p.out ? p.r.diro : p.r.dir
			let dir = p.r.dir
			s += `<path d="m${(px)*10},${(py)*10} ${dir}" />`
			let pname = p.name
			let ext = ""
			if (pname[0]=="~") {
				//pname = pname.slice(1)
				//ext = "class=overline"
			}
			pname += suffix
			if (p.side==0) {
				s += `<text transform="translate(${(px)*10} ${(py+0.2)*10}) rotate(90)">${p.name}</text>`
			} if (p.side==1) {
				s += `<text x=${(px-0.2)*10} y=${(py)*10} text-anchor=end ${ext}>${pname}</text>`
				s += `<text x=${(px+0.2)*10} y=${(py-0.2)*10} class=num>${p.num}</text>`
			} if (p.side==2) {
				s += `<text transform="translate(${(px)*10} ${(py-0.2)*10}) rotate(-90)">${p.name}</text>`
			} if (p.side==3) {
				s += `<text x=${(px+0.2)*10} y=${(py)*10} ${ext}>${pname}</text>`
				s += `<text x=${(px-0.2)*10} y=${(py-0.2)*10} text-anchor=end class=num>${p.num}</text>`
			}
		}
		return s + "</g>"
	}
	function lookup_pin(des) {
		let [part,pin] = des.split(".")
		part = part.toUpperCase()
		pin = pin.toUpperCase()
		part = byname[part]
		pin = part.symbol.pins.find(x=>(x.num==pin||x.name==pin))
		return [part, pin]
	}
	function draw_conn2(desc) {
		desc = desc.split(" ")
		let s = ""
		let s2 = ""
		let px = 0
		let py = 0
		let dir = 0
		let landmarks = []
		let lineto = (c)=>{s+=c+px*10+","+py*10}
		let drawing = false
		for (let item of desc) {
			if (item[0]=="+") {
				for (let move of item.slice(1).matchAll(/[a-zA-Z][^a-zA-Z]*/g)) {
					move = move[0]
					let num = +move.slice(1)
					if (move[0]=="h") {
						px += num
						lineto('L')
					} else if (move[0]=='v') {
						py += num
						lineto('L')
					} else if (move[0]=='J') {
						landmarks.push([px,py])
						s2 += `<circle cx=${px*10} cy=${py*10} r=1.5 class=junction />`
					} else if (move[0]=='P') {
						0,[px,py] = landmarks.pop()
						lineto('M')
					} else {
						throw new Error('oh no +'+move[0])
					}
				}
			} else if (item[0]=="=") {
				let text = item.slice(1)
				if (dir==3)
					s2 += `<text x=${(px-0.2)*10} y=${(py)*10} class=net text-anchor=end>${text}</text>`
				else 
					s2 += `<text x=${(px+0.2)*10} y=${(py)*10} class=net text-anchor=start>${text}</text>`
			} else {
				if (item=="VCC") {
					s += `v-3 h-1 l1,-3 l1,3 h-1 v-3`
				} else if (item=="GND") {
					s += `v3 h-3 l3,3 l3,-3 h-3`
				} else if (item=="NC") {
					s += `m-2,-2 l4,4 m0-4 l-4,4`
				} else {
					let [part, pin] = lookup_pin(item)
					dir = pin.side
					px = pin.e.x+part.pos.x
					py = pin.e.y+part.pos.y
					if (drawing)
						lineto('L')
					else
						lineto('M')
					drawing = true
				}
			}
		}
		return `<path d="`+s+`"/>`+s2
	}
	let s = ''
	for (let p of placed) {
		byname[p.name] = p
		s += generate_symbol(p)
	}
	s += "<g stroke=green stroke-width=1px fill=none>"
	for (let conn of cons) {
		if (conn[0]=="<")
			s+=conn
		else
			s += draw_conn2(conn)
	}
	s += "</g>"
	$dest.innerHTML = s
</script>
